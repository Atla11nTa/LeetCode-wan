# Day2 刷题笔记

1. 找出数组中唯一出现的数字，除此之外其他均出现两次。要求空间O(1)，时间O(n)

   >由于其他数字出现偶数次，利用异或运算的性质，并且异或运算支持__交换律__
   >
   >- `异或性质1`: 任何数与自身异或为0
   >- 异或性质2: 任何数与0异或为自身
   >
   >举例:[2,1,1,2,-1]:  2^1^1^2^-1 =  2^2^1^1^-1 = -1.
   >
   >利用此性质可得解。

2. 建立一个最小栈，可以快速读取最小值。

   >`常规做法`：入栈时判断，保存min，在出栈时判断，若出栈元素为min，需要更新min值
   >
   >`优化解法(我的想法)`：用一个数组保存栈中每一个元素入栈时的min值，当出栈时，数组长度相应的减一。节约时间，但增加了空间。

3. 求一个数组中元素出现次数大于n/2的元素：“投票算法”

   >* 当arr[i]与tag相等时，count++
   >* 不等时，count--
   >* count == 0时，更改tag = arr[i]

4. 将无符号整型变量的二进制形式反转。1011 -> 1101

   >* `取变量的每一位`：n&1取第0位，然后n>>1，循环取得每一位
   >
   >```C++
   >for(int i =0;i<32;i++)
   >        {
   >            re = (re<<1)+(n&1);
   >            n >>= 1;
   >        }
   >```

5. [简单dp问题](../day2/day2-7/main.cpp)

   >* 建立dp数组，初试化数组。
   >* 建立状态转移方程，一般为dp[i] = better(dp[i-1], dp[i-1]+arr[i]); //加入i次结果是否比dp[i-1]更优

6. __头结点非空__的链表元素删除问题

   >链表删除问题虽然简单，但是无空头结点的链表，删除时容易在一些特殊情况上出错。
   >
   >较好的解决方法是建立一个空节点dump指向head，然后进行删除操作，然后返回dump->next